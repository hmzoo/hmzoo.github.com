{"ts":1369408596904,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"---\nlayout: post\ntitle: \"raspberry_1\"\ndescription: \"\"\ncategory: \ntags: []\n---\n{% include JB/setup %}\n"]],"start1":0,"start2":0,"length1":0,"length2":101}]],"length":101}
{"contributors":[],"silentsave":false,"ts":1369408624054,"patch":[[{"diffs":[[0,"erry"],[-1,"_1"],[1," et arduino"],[0,"\"\nde"]],"start1":30,"start2":30,"length1":10,"length2":19},{"diffs":[[0,"\ntags: ["],[1,"raspberry,arduino"],[0,"]\n---\n{%"]],"start1":73,"start2":73,"length1":16,"length2":33}]],"length":127,"saved":false}
{"ts":1369408773861,"patch":[[{"diffs":[[0,"etup %}\n"],[1,"\n#Objectif de l'installation\n\nTransmettre les variations d'un capteur capacitif distant vers une application Pure Data:\n\nCapture|>|Émission|>|Réception\n--|--|--|--|--\nCapteur+Arduino|*USB*|raspberry|*ethernet/WIFI*|PC\napplication Arduino|*json*|nodejs|*OSC*|application Pure Data\n\n1. **La capture :** le montage arduino et capteur capacitif envoie les valeurs captées sur le port serie (USB) du Raspberry. \n2. **L'émission** l'application nodejs récupère et retransmet ces valeurs vers le patch Pure Data par le réseau, en utilisant le protocole OSC .\n3. **La réception :** le serveur OSC du patch Pure Data reçoit les valeurs et le reste du patch peut les traiter.\n \n\n#Configuration Arduino\n\n\n##Principes du montage\nL'application Arduino utilise la librairie *Capacitive Sensing Library* :\n\n[http://playground.arduino.cc/Main/CapacitiveSensor](http://playground.arduino.cc/Main/CapacitiveSensor)\n\nle principe du capteur capacitif est de calculer le temps que prendra une broche à retrouver le même état qu'une autre. la capacité d'un objet proche (corps humain) va ralentir cette transition. La valeur calculée est donc une unité arbitraire qui correspond à la durée de la transition.\n\n\n\n![](http://i.imgur.com/ZtsVNNn.jpg)\n\n##Schéma du montage Arduino\n\n![](http://i.imgur.com/Q0cmcA2.png)\n\nCode couleur des résistances : [http://www.dcode.fr/code-couleur-resistance](http://www.dcode.fr/code-couleur-resistance)\n\nÉditeur de schémas Arduino : [http://fritzing.org/](http://fritzing.org/)\n\n##Sketch Arduino : sketch.ino\n\n   \n    #include <CapacitiveSensor.h>\n    \n    /*\n     * d'après\n     * CapitiveSense Library Demo Sketch\n     * Paul Badger 2008\n     *\n     * Utiliser une résistance de valeur élevée par exemple 10M entre les broches 'envoyer' et 'recevoir'\n     * La sensibilité des effets de résistance peut être testé avec des résistances de 50K à 50M.\n     * Des grandes valeurs de résistance donnent des valeurs de capture plus grandes.\n     * le capteur est connecter à la broche 'recevoir'\n     */\n    \n    // le capteur est sur sur la broche 2 et la résistance entre la broche 2 et 4.\n    CapacitiveSensor   cs_4_2 = CapacitiveSensor(4,2);\n    \n    \n    void setup()\n    {\n    //l'autocalibrage est désinstallé\n     cs_4_2.set_CS_AutocaL_Millis(0xFFFFFFFF); \n      \n    //ouvre le port série et fixe le débit de communication à 9600 bauds (9600 bits par seconde)\n      Serial.begin(9600);\n    }\n    \n    void loop()\n    {\n      long start = millis();\n      long total =  cs_4_2.capacitiveSensor(20);\n    \n     \n    //écriture au format json des données à transmettre sur le port série pour pouvoir être traité par Nodejs\n         Serial.println(\"{\\\"cap\\\":\\\"\" + String(total) +\n    \t\t\t\"\\\", \\\"perf\\\":\\\"\" + String(millis() - start)+\n    \t\t\t\"\\\"}\");\n     \n    // délai arbitraire pour limiter l'envoi sur le port série\n    delay(1);  \n    \n    }\n\n\n\n\n\n#Préparation du Raspberry\n\nLe Raspberry utilise l'image [Raspbian \"wheezy\"](http://www.raspberrypi.org/downloads) (2013-02-09).\n\nPour de meilleurs performances les applications inutiles sont désactivées et la mémoire pour les applications graphiques est réduite au maximum. \n    \n`sudo raspiconfig` puis `memory_split   Change memory split` permet de choisir la répartition de la mémoire entre le processeur de calcul CPU et le processeur graphique GPU.\n\nLa mémoire GPU est  à régler en fonction de l'utilisation finale du Raspberry. Si la mémoire GPU est inférieure à 64MB, il ne sera plus possible d'utiliser les outils multimédias comme *omxplayer*.  \n\nLe reste de la configuration peut se faire sans problème en ligne de commande.\n\n## Accès en FTP au Raspberry. \nPour faciliter les échanges avec le raspberry, il est possible d'installer un serveur ftp comme proftpd.\n\n\n- installation : `sudo apt-get install proftpd `  \n- activation de l'accès aux répertoires personnels :  \ndé-commenter `#DefaultRoot     ~` dans `/etc/proftpd/proftpd.conf`\n\nCe service permet d'éditer directement les applications Nodejs avec un éditeur de texte connecté en FTP (notepad++ par exemple). Pour se connecter on utilise l'adresse IP du Raspberry, le nom d'utilisateur \"*pi*\" et le mot de passe \"*raspberry*\".   \n\nÉditeur de texte avec client FTP : [notepad++](http://notepad-plus-plus.org/fr/)\n\n## Installation de ino\n\nIno permet la compilation et l'envoi des sketch vers l'arduino en ligne de commande.\n\nvoir : [http://inotool.org](http://inotool.org)\n\n###Installation de l'installeur python\n\n    sudo apt-get install python-pip\n\n###Installation de ino avec l'installeur python :\n\n    sudo pip install ino\n\n###Installation de picocom\n\npicocom sert à la communication série avec la carte arduino\n\n    sudo apt-get install picocom\n\n###Installation de l'IDE Arduino \n\nla dernière version de l'IDE arduino pour linux 32b peut être récupéré ici : [http://arduino.cc/en/Main/Software](http://arduino.cc/en/Main/Software)\n\n    cd /usr/local/share\n    sudo wget http://arduino.googlecode.com/files/arduino-1.0.4-linux32.tgz\n\tsudo tar -zxf arduino-1.0.4-linux32.tgz\n\tsudo ln -s arduino-1.0.4 arduino\n\tsudo rm arduino-1.0.4-linux32.tgz\n\nIl faut modifier les binaire x86 de flashage avrdude de l'IDE arduino. Il faut installer la version pour ARM.\n\n\tsudo apt-get install avrdude avr-libc\n    sudo mv /usr/local/share/arduino/hardware/tools/avr/bin /usr/local/share/arduino/hardware/tools/avr/bin.disabled\t\t\n    sudo mv /usr/local/share/arduino/hardware/tools/avrdude /usr/local/share/arduino/hardware/tools/avrdude.x86\n    sudo mv /usr/local/share/arduino/hardware/tools/avrdude.conf /usr/local/share/arduino/hardware/tools/avrdude.conf.x86\n    sudo ln -s /usr/bin/avrdude /usr/local/share/arduino/hardware/tools/avrdude\n    sudo ln -s /etc/avrdude.conf /usr/local/share/arduino/hardware/tools/avrdude.conf\n\t\n### Utilisation de ino\n\n####les principales commandes de ino \n\ncommande|description\n---|---\nino init | initialise  un projet dans le répertoire courant\nino build | compile le sketch en code \nino clean | nettoie les fichiers créés pendant la compilation\nino list-models | Liste les modèles Arduino supportés\nino upload | envoie le code sur l'arduino\nino serial | ouvre un moniteur du port série\nino preproc | transforme un sketch en code source C++\n\n\n\n####Initialisation :\n\nexemple de création de projet arduino dans le répertoire /home/pi/arduino :\n\n    mkdir /home/ip/arduino\n    cd /home/ip/arduino\n    ino init\n\nles répertoires /home/ip/arduino/lib et /home/ip/arduino/src sont créés. Le répertoire  /home/ip/arduino/src contient un sketch de base : sketch.ino. Il peut être renommé et modifié.\n\nLe répertoire lib va accueillir les librairies externes utilisées dans le sketch. Pour le projet il faudra y placer le répertoire CapacitiveSensor correspondant à la librairie *Capacitive Sensing Library*.\n\n####Compilation\n\nUne fois le sketch créé et les librairies installées ont peut compiler le projet.\n\nOn efface la compilation précédente.\n\n    ino clean\n\nOn compile le projet pour la plate forme par default (arduino uno)\n\n    ino build\n\nPour compiler pour un modèle de carte différent, exemple: `ino build -m atmega328`  \nLa liste des modèles de cartes est obtenue avec la commande `ino list-models`\n\nLe résultat de la compilation se retrouve dans le répertoire *.build* .\n\n####Téléversement\n\nPour téléversé sur un arduino uno la commande est simplement :\n\n    ino upload\n\nEt pour un modèle de carte différent :\npar exemple pour un Arduino Duemilanove w/ ATmega328: \n\n    ino upload -m atmega328\n\n####Connexion sur le port série\n\nLa commande pour ouvrir un moniteur de port série est :\n\n    ino serial\n\n##Installation de la derniere version Nodejs\nLes dépôts officiels ne disposent pas actuellement de la dernière version de Nodejs . Cela pose un problème de compatibilité avec l'utilisation du module serialport.\n\nUne solution pour installer la dernière version de Nodejs est de télécharger un paquet d'installation déjà compilé. On peut en trouver un ici:\n\n[https://github.com/itwars/nodejs-ARM/](https://github.com/itwars/nodejs-ARM/)\n\nIl faut télécharger la dernière version pour Raspberry et l'installer.\n\nAvec la version de fin avril 2013 cela donne :\n \n    sudo dpkg -i nodejs_0.10.1-1vr~wheezy1_armhf.deb\n\n\n#L'application Nodejs\n\nLe rôle de l'application nodejs et de réceptionner les messages de l'Arduino et de les retransmettre sur le réseau vers l'ordinateur exécutant Pure Data.\n\n##Création du répertoire de l'application\n\nLa première étape est de créer le dossier pour stocker l'application :\n\n    cd ~\n    mkdir app \n\nLe résultat est un nouveau dossier dans le répertoire utilisateur : `/home/pi/app`\n\n## Installation des modules \n\nPour fonctionner l'application va faire appel a deux modules :\n\n- le module node-serialport\n- le module node-osc\n\nIl faut les installer dans le répertoire de l'installation :\n\n    cd /home/pi/app\n    npm install serialport\n    npm install node-osc\n\n##L'application \n\nOn créé maintenant le fichier de l'application nodejs : `/home/pi/app/app.js `\n\n    \"use strict\";\n    \n\t//création du client OSC\n\t//le client envoie les données osc vers le serveur 10.12.47.104 sur le port 9001\n    var osc = require('node-osc');\n    var client = new osc.Client('10.12.47.104', 9001);\n    \n    \n    //Le port série de l'arduino correspond au périphérique /dev/ttyACM0\n    var arduinoSerialPort = '/dev/ttyACM0';\n    \n    var serialport = require('serialport');\n    var serialPort = new serialport.SerialPort(arduinoSerialPort,\n    {//Écoute du port série pour réagir aux données provenant d’Arduino par USB\n    \tparser: serialport.parsers.readline('\\n')\n    });\n    \n    serialPort.on('data', function (data)\n    {//Quand une nouvelle ligne de texte est reçue en provenance d’Arduino par USB\n    \ttry\n    \t{\n\n\t\t//les données reçues sont au format json\n    \tvar j = JSON.parse(data);\n\n\t\t//la valeur récupérée est envoyée sur l'adresse OSC /rasp/1\n    \tclient.send('/rasp/1', j.cap);\n    \t}\n    \tcatch (ex)\n    \t{\n    \t\tconsole.warn(ex);\n    \t}\n    });\n\n##Lancement automatique de l'application\n\n**forever**  surveille qu'un service nodejs s’exécute en permanence. Il relancera le script en cas de crash.\n\n### Installation de forever\n\nil faut l'installer de manière globale (option -g).\n\n    sudo npm install forever -g\n\n### Utilisation de forever\n\nLancement d'un script : `forever start app.js`\n\nLister les scripts en cours d’exécution : `forever list`\n\nArrêter un script `forever stop app.js`\n\nArrêter tout les scripts : `forever stopall`\n\n### lancement de l'application au démarrage du raspberry\n\nPour déclencher le lancement de l'application au démarrage du Raspberry, on peut utiliser **cron**.\n\nÉditer la table cron de l'utilisateur pi :\n    \n    crontab -u pi -e\n\nAjouter la ligne :\n\n    @reboot /usr/local/bin/forever start /home/pi/app/app.js\n\nL'application sera lancée à chaque démarrage du Raspberry\n\n\n\n#Le patch Pure Data\n\nIl faut utiliser la librairie mrpeach.\n\n![](http://i.imgur.com/gV8A4bP.png)\n\n\nplus d'informations ici : [http://en.flossmanuals.net/pure-data/network-data/osc/](http://en.flossmanuals.net/pure-data/network-data/osc/)\n"]],"start1":119,"start2":119,"length1":8,"length2":11038}]],"length":11157,"saved":false}
